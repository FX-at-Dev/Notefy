<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notefy - Web-Based Notes Making and Sharing Application</title>
  <link rel="stylesheet" href="./css/style.css" />
  <!-- CodeMirror theme (via CDN) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@codemirror/theme-one-dark@6.0.0/theme-one-dark.css" />
  <style>
    .cm-editor { height:100%; min-height:320px; }
    .draw-canvas { width:800px; height:500px; background:#fff; border-radius:8px; }
    /* ensure fallback textarea looks integrated */
    #editor-fallback { width:100%; height:100%; min-height:320px; resize:none; background:transparent; color:inherit; border:1px solid rgba(255,255,255,0.06); padding:12px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    /* simple modal inner styling for iframe import */
    #import-iframe-modal .import-iframe-inner { padding: 12px; background: var(--panel-bg, #0f0f10); border-radius: 10px; box-shadow: 0 6px 30px rgba(0,0,0,0.45); }
    .modal.hidden { display: none; }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="left">
      <button id="btn-new" class="icon-btn">New</button>
      <button id="btn-import" class="icon-btn">Import</button>
      <button id="btn-export" class="icon-btn">Export</button>
      <button id="btn-draw" class="icon-btn">Draw</button>
    </div>
    <div class="center">Notefy</div>
    <div class="right">
      <button id="btn-quickswitch" class="icon-btn">Quick</button>
      <button id="btn-profile" class="icon-btn">Profile</button>
    </div>
  </header>

  <div id="workspace" class="workspace">
    <aside class="sidebar">
      <input id="search-input" placeholder="Search (tag:project)" />
      <div id="notes-list" class="notes-list"></div>
    </aside>

    <main class="editor-area">
      <div class="editor-toolbar">
        <input id="note-title" placeholder="Untitled note" class="title-input" />
        <div class="status" id="status-bar">Saved</div>
      </div>

      <div class="panes">
        <section class="pane pane-left">
          <div id="editor-container" style="height:100%;min-height:320px;position:relative;">
            <!-- CodeMirror root (will be shown when rich editor initializes) -->
            <div id="cm-root" style="height:100%;min-height:320px;display:none;"></div>
            <!-- fallback textarea (shown only when CodeMirror fails) -->
            <textarea id="editor-fallback" style="display:none;"></textarea>
          </div>
        </section>

        <section class="pane pane-right">
          <div id="preview" class="preview"></div>
        </section>
      </div>
    </main>

    <aside class="rightbar">
      <h4>Backlinks</h4>
      <div id="backlinks">No backlinks yet</div>
    </aside>
  </div>

  <!-- Drawpad modal -->
  <div id="draw-modal" class="modal hidden" role="dialog" aria-hidden="true">
    <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
      <button id="draw-save" class="btn">Save</button>
      <button id="draw-clear" class="btn ghost">Clear</button>
      <button id="draw-close" class="btn ghost">Close</button>
      <label style="margin-left:auto">Brush:
        <input id="draw-size" type="range" min="1" max="30" value="4" />
      </label>
    </div>
    <div id="draw-container" class="draw-canvas"></div>
  </div>

  <!-- Quick Switcher modal -->
  <div id="qs-modal" class="modal hidden" role="dialog" aria-hidden="true">
    <input id="qs-input" placeholder="Quick switch (Ctrl/Cmd+P)" />
    <div id="qs-results"></div>
  </div>

  <!-- Import iframe modal (Option A: import.html loaded inside iframe + postMessage) -->
  <div id="import-iframe-modal" class="modal hidden" role="dialog" aria-hidden="true">
    <div class="import-iframe-inner" style="max-width:880px;width:100%;height:80vh;padding:12px;">
      <button id="import-iframe-close" class="btn ghost" style="float:right">Close</button>
      <div style="clear:both;height:8px"></div>
      <iframe id="import-iframe" src="about:blank" style="width:100%;height:calc(100% - 40px);border:0;border-radius:8px"></iframe>
    </div>
  </div>

  <!-- Inlined core frontend logic: attempts CodeMirror then falls back to textarea -->
  <script type="module">
  // Core behavior: try to init rich editor (CodeMirror). If imports or init fail, enable fallback.
  import Dexie from 'https://cdn.jsdelivr.net/npm/dexie@3.2.3/dist/dexie.mjs'
  import 'https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js'
const md = new window.markdownit()

  const db = new Dexie('NotesAppDB')
  db.version(1).stores({ notes: 'id,title,updated_at,created_at' })

  const statusBar = document.getElementById('status-bar')
  const preview = document.getElementById('preview')
  const notesList = document.getElementById('notes-list')
  const titleInput = document.getElementById('note-title')

  let cmView = null
  let currentNote = null
  let saveTimer = null

  async function saveNoteToDB(note) {
    note.updated_at = new Date().toISOString()
    if (!note.id) note.id = `local-${Date.now()}`
    await db.notes.put(note)
  }
  async function loadNotesList() {
    const notes = await db.notes.orderBy('updated_at').reverse().toArray()
    notesList.innerHTML = notes.map(n => `<div class="note-item" data-id="${n.id}">${n.title || 'Untitled'}</div>`).join('')
  }
  async function getNoteById(id) {
    return db.notes.get(id)
  }

  function debounceSave(fn, delay=900) {
    clearTimeout(saveTimer)
    saveTimer = setTimeout(fn, delay)
  }

  // Try to initialize CodeMirror-rich editor
  (async function tryInitRichEditor(){
    try {
      // dynamic imports for CodeMirror modules
      const [{ EditorView, basicSetup }, { EditorState }, { markdown }, { oneDark }] = await Promise.all([
        import('https://esm.sh/@codemirror/basic-setup@0.19.1'),
        import('https://esm.sh/@codemirror/state@0.19.1'),
        import('https://esm.sh/@codemirror/lang-markdown@0.19.2'),
        import('https://esm.sh/@codemirror/theme-one-dark@6.0.0')
      ].map(p => p));

      // Note: some esm.sh returns module shape differently; normalize:
      const BasicSetup = EditorView && EditorView.basicSetup ? EditorView.basicSetup : basicSetup.basicSetup || basicSetup
      // create editor state and view
      const startState = EditorState.EditorState.create ? EditorState.EditorState.create({
        doc: '',
        extensions: [BasicSetup, markdown.markdown(), oneDark.oneDark]
      }) : EditorState.create({
        doc: '',
        extensions: [basicSetup, markdown(), oneDark]
      })

      const cmRoot = document.getElementById('cm-root')
      // ensure cm-root visible and hide fallback
      try { cmRoot.style.display = 'block' } catch(e){}
      const ta = document.getElementById('editor-fallback')
      try { if (ta) ta.style.display = 'none' } catch(e){}

      cmView = new EditorView.EditorView ? new EditorView.EditorView({ state: startState, parent: cmRoot }) : new EditorView({ state: startState, parent: cmRoot })

      // hook into dispatch to detect changes
      const originalDispatch = cmView.dispatch.bind(cmView)
      cmView.dispatch = (tr) => {
        originalDispatch(tr)
        if (tr.docChanged) {
          const text = cmView.state.doc.toString()
          preview.innerHTML = md.render(text || '')
          statusBar.textContent = 'Editing...'
          debounceSave(async ()=> {
            const note = {
              id: currentNote?.id,
              title: titleInput.value || 'Untitled',
              body: cmView.state.doc.toString() || '',
              created_at: currentNote?.created_at || new Date().toISOString()
            }
            await saveNoteToDB(note)
            currentNote = note
            statusBar.textContent = 'Saved'
            loadNotesList()
          })
        }
      }

      // load existing notes
      await loadNotesList()
      const notes = await db.notes.orderBy('updated_at').reverse().toArray()
      if (notes.length) {
        const first = notes[0]
        currentNote = first
        titleInput.value = first.title || ''
        cmView.dispatch({ changes: { from: 0, to: cmView.state.doc.length, insert: first.body || '' } })
        preview.innerHTML = md.render(first.body || '')
        statusBar.textContent = 'Loaded'
        window.__currentNoteId = first.id
      } else {
        currentNote = { id: `local-${Date.now()}`, title:'', body:'', created_at: new Date().toISOString() }
      }

      // UI handlers
      document.getElementById('btn-new').addEventListener('click', ()=> {
        currentNote = { id:`local-${Date.now()}`, title:'', body:'', created_at: new Date().toISOString() }
        titleInput.value = ''
        cmView.dispatch({ changes: { from: 0, to: cmView.state.doc.length, insert: '' } })
        preview.innerHTML = ''
      })

      notesList.addEventListener('click', async (ev) => {
        const id = ev.target.dataset.id
        if (!id) return
        const note = await getNoteById(id)
        if (!note) return
        currentNote = note
        titleInput.value = note.title || ''
        cmView.dispatch({ changes: { from: 0, to: cmView.state.doc.length, insert: note.body || '' } })
        preview.innerHTML = md.render(note.body || '')
        statusBar.textContent = 'Loaded'
      })

      // keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='s') {
          e.preventDefault()
          debounceSave(async ()=> {
            const note = {
              id: currentNote?.id,
              title: titleInput.value || 'Untitled',
              body: cmView.state.doc.toString() || '',
              created_at: currentNote?.created_at || new Date().toISOString()
            }
            await saveNoteToDB(note)
            currentNote = note
            statusBar.textContent = 'Saved'
            loadNotesList()
          }, 0)
        }
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='p') {
          e.preventDefault()
          document.getElementById('qs-modal').classList.remove('hidden')
          document.getElementById('qs-input').focus()
        }
      })

      window.__openNote = async (id) => {
        const note = await getNoteById(id)
        if (!note) return
        currentNote = note
        titleInput.value = note.title || ''
        cmView.dispatch({ changes: { from: 0, to: cmView.state.doc.length, insert: note.body || '' } })
        preview.innerHTML = md.render(note.body || '')
      }

      // show rich editor was initialized
      console.info('Rich editor initialized')
      return
    } catch (err) {
      // If any error happens during rich editor init, fall through to fallback
      console.warn('Rich editor initialization failed, enabling fallback editor. Error:', err)
      enableFallbackEditor()
    }
  })();

  // Fallback editor implementation
  async function enableFallbackEditor() {
    try {
      const cmRoot = document.getElementById('cm-root')
      const ta = document.getElementById('editor-fallback')
      // hide cm-root and show textarea
      try { if (cmRoot) cmRoot.style.display = 'none' } catch(e){}
      ta.style.display = 'block'

      // load existing notes
      await db.open()
      const notes = await db.notes.orderBy('updated_at').reverse().toArray()
      if (notes.length) {
        currentNote = notes[0]
        titleInput.value = currentNote.title || ''
        ta.value = currentNote.body || ''
        preview.innerHTML = md.render(ta.value || '')
      } else {
        currentNote = { id: `local-${Date.now()}`, title:'', body:'', created_at:new Date().toISOString() }
      }
      await loadNotesList()

      // input handlers
      let fallbackSaveTimer = null
      ta.addEventListener('input', ()=> {
        preview.innerHTML = md.render(ta.value || '')
        statusBar.textContent = 'Editing...'
        clearTimeout(fallbackSaveTimer)
        fallbackSaveTimer = setTimeout(async ()=>{
          const note = {
            id: currentNote?.id || `local-${Date.now()}`,
            title: titleInput.value || 'Untitled',
            body: ta.value || '',
            created_at: currentNote?.created_at || new Date().toISOString()
          }
          await saveNoteToDB(note)
          currentNote = note
          statusBar.textContent = 'Saved'
          loadNotesList()
        }, 700)
      })

      // notes list open
      notesList.addEventListener('click', async (ev) => {
        const id = ev.target.dataset.id
        if (!id) return
        const note = await getNoteById(id)
        if (!note) return
        currentNote = note
        titleInput.value = note.title || ''
        ta.value = note.body || ''
        preview.innerHTML = md.render(ta.value || '')
      })

      // New button
      document.getElementById('btn-new').addEventListener('click', ()=> {
        currentNote = { id: `local-${Date.now()}`, title:'', body:'', created_at:new Date().toISOString() }
        titleInput.value = ''
        ta.value = ''
        preview.innerHTML = ''
      })

      // Quick switch keyboard
      document.addEventListener('keydown', (e)=> {
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==='p') {
          e.preventDefault()
          document.getElementById('qs-modal').classList.remove('hidden')
          document.getElementById('qs-input').focus()
        }
      })

      console.info('Fallback editor ready')
    } catch (e) {
      console.error('Fallback editor failed to initialize', e)
      // As a last resort, show a basic editable div
      const fallback = document.createElement('div')
      fallback.contentEditable = 'true'
      fallback.style.minHeight = '200px'
      fallback.style.padding = '12px'
      document.getElementById('cm-root').appendChild(fallback)
    }
  }

  // Quick Switcher small logic - searches local notes (works for both editors)
  document.getElementById('qs-input')?.addEventListener('input', async (ev) => {
    const q = (ev.target.value||'').toLowerCase().trim()
    if (!q) { document.getElementById('qs-results').innerHTML = ''; return }
    const notes = await db.notes.orderBy('updated_at').reverse().toArray()
    const hits = notes.filter(n => (n.title||'').toLowerCase().includes(q) || (n.body||'').toLowerCase().includes(q)).slice(0,12)
    document.getElementById('qs-results').innerHTML = hits.map(h => `<div class="note-item" data-id="${h.id}">${h.title||'Untitled'}</div>`).join('')
  })

  document.getElementById('qs-results')?.addEventListener('click', (ev) => {
    const id = ev.target.dataset.id
    if (!id) return
    document.getElementById('qs-modal').classList.add('hidden')
    if (window.__openNote) window.__openNote(id)
  })

  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') document.getElementById('qs-modal').classList.add('hidden')
  })

  // ------------------ UI wiring for navbar + drawpad + import/export ------------------

  // Helper: get editor content and set editor content (works for CodeMirror or fallback)
  function getEditorContent() {
    const ta = document.getElementById('editor-fallback');
    if (window.cmView && cmView.state) {
      return cmView.state.doc.toString();
    }
    return ta ? ta.value : '';
  }
  async function setEditorContent(text) {
    const ta = document.getElementById('editor-fallback');
    if (window.cmView && cmView.dispatch) {
      cmView.dispatch({ changes: { from: 0, to: cmView.state.doc.length, insert: text || '' } });
    } else if (ta) {
      ta.value = text || '';
      preview.innerHTML = md.render(ta.value || '');
    }
  }

  // Quick Switcher button
  document.getElementById('btn-quickswitch')?.addEventListener('click', (e) => {
    document.getElementById('qs-modal').classList.remove('hidden');
    document.getElementById('qs-modal').setAttribute('aria-hidden', 'false');
    document.getElementById('qs-input').focus();
  });

  // Profile button (placeholder behavior)
  document.getElementById('btn-profile')?.addEventListener('click', (e) => {
    // Replace with your profile modal logic — currently shows a placeholder
    alert('Profile: feature not implemented yet — add a profile modal or routing here.');
  });

  // Export button: download current note content as .md
  document.getElementById('btn-export')?.addEventListener('click', (e) => {
    const content = getEditorContent() || '';
    const filename = (titleInput.value || 'note').replace(/[^\w\- ]+/g, '') + '.md';
    const blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
    statusBar.textContent = 'Exported';
  });

  // ------------------ Simple drawpad canvas init + handlers ------------------
  let _drawCtx = null;
  let _drawCanvas = null;
  let _isDrawing = false;
  function initDrawCanvasIfNeeded() {
    const container = document.getElementById('draw-container');
    if (!container) return;
    if (container.querySelector('canvas')) return; // already initialized

    const canvas = document.createElement('canvas');
    // make canvas fill container
    function resizeCanvas() {
      const rect = container.getBoundingClientRect();
      canvas.width = Math.max(800, Math.floor(rect.width));
      canvas.height = Math.max(500, Math.floor(rect.height));
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    canvas.style.borderRadius = '8px';
    canvas.style.touchAction = 'none';
    container.innerHTML = '';
    container.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    ctx.lineWidth = Number(document.getElementById('draw-size')?.value || 4);

    _drawCanvas = canvas;
    _drawCtx = ctx;

    function pointerDown(e) {
      _isDrawing = true;
      const p = getPos(e);
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
    }
    function pointerMove(e) {
      if (!_isDrawing) return;
      const p = getPos(e);
      ctx.lineTo(p.x, p.y);
      ctx.stroke();
    }
    function pointerUp(e) {
      if (!_isDrawing) return;
      _isDrawing = false;
      ctx.closePath();
    }
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      const clientX = e.touches ? e.touches[0].clientX : e.clientX;
      const clientY = e.touches ? e.touches[0].clientY : e.clientY;
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    canvas.addEventListener('pointerdown', (ev) => canvas.setPointerCapture?.(ev.pointerId) || pointerDown(ev));
    canvas.addEventListener('pointermove', pointerMove);
    canvas.addEventListener('pointerup', pointerUp);
    canvas.addEventListener('pointercancel', pointerUp);
    canvas.addEventListener('touchstart', pointerDown);
    canvas.addEventListener('touchmove', pointerMove);
    canvas.addEventListener('touchend', pointerUp);

    // brush size control
    document.getElementById('draw-size')?.addEventListener('input', (ev) => {
      const v = Number(ev.target.value);
      if (_drawCtx) _drawCtx.lineWidth = v;
    });

    // save button -> download png
    document.getElementById('draw-save')?.addEventListener('click', () => {
      if (!_drawCanvas) return;
      _drawCanvas.toBlob((blob) => {
        const filename = `${(titleInput.value || 'drawing').replace(/[^\w\- ]+/g,'')}.png`;
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      }, 'image/png');
    });

    // clear
    document.getElementById('draw-clear')?.addEventListener('click', () => {
      if (!_drawCtx || !_drawCanvas) return;
      _drawCtx.clearRect(0,0,_drawCanvas.width,_drawCanvas.height);
      _drawCtx.fillStyle = '#ffffff';
      _drawCtx.fillRect(0,0,_drawCanvas.width,_drawCanvas.height);
    });

    // close
    document.getElementById('draw-close')?.addEventListener('click', () => {
      const modal = document.getElementById('draw-modal');
      modal.classList.add('hidden');
      modal.setAttribute('aria-hidden', 'true');
    });
  }

  // Open draw modal
  document.getElementById('btn-draw')?.addEventListener('click', (ev) => {
    const modal = document.getElementById('draw-modal');
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
    initDrawCanvasIfNeeded();
  });

  // Also initialize draw canvas if modal is made visible in other ways
  const drawObserver = new MutationObserver((mutations) => {
    for (const m of mutations) {
      if (m.type === 'attributes' && m.attributeName === 'class') {
        const modal = document.getElementById('draw-modal');
        if (modal && !modal.classList.contains('hidden')) initDrawCanvasIfNeeded();
      }
    }
  });
  drawObserver.observe(document.getElementById('draw-modal'), { attributes: true });

  // ------------------ small UX tweaks ------------------
  // hide quick switcher when clicked outside
  document.addEventListener('click', (e) => {
    const qs = document.getElementById('qs-modal');
    if (!qs) return;
    if (!qs.classList.contains('hidden')) {
      if (!qs.contains(e.target) && e.target.id !== 'btn-quickswitch') {
        qs.classList.add('hidden');
        qs.setAttribute('aria-hidden', 'true');
      }
    }
  });

  // ------------------ Import iframe modal + postMessage integration ----------
  // Open import iframe modal when clicking Import button (overrides any previous handler)
  document.getElementById('btn-import').onclick = (e) => {
    e.preventDefault();
    const modal = document.getElementById('import-iframe-modal');
    if (!modal) return;
    // load import.html fresh into iframe
    const iframe = document.getElementById('import-iframe');
    iframe.src = 'import.html';
    modal.classList.remove('hidden');
    modal.setAttribute('aria-hidden', 'false');
  };

  // Close button for iframe modal
  document.getElementById('import-iframe-close')?.addEventListener('click', () => {
    const modal = document.getElementById('import-iframe-modal');
    if (!modal) return;
    modal.classList.add('hidden');
    modal.setAttribute('aria-hidden', 'true');
    // clear iframe to free resources
    const iframe = document.getElementById('import-iframe');
    iframe.src = 'about:blank';
  });

  // Listen for messages from import.html
  window.addEventListener('message', async (ev) => {
    // If import.html is hosted from a different origin, replace '*' in child and
    // check ev.origin here to ensure it matches allowed origin.
    const data = ev.data;
    if (!data || data.type !== 'imported-file') return;

    const { title, text } = data;

    // put contents into editor (works for rich editor or fallback)
    titleInput.value = title || '';
    await setEditorContent(text || '');
    preview.innerHTML = md.render(text || '');
    statusBar.textContent = 'Imported';

    // save imported note to DB
    try {
      const note = {
        id: `local-${Date.now()}`,
        title: title || 'Imported note',
        body: text || '',
        created_at: new Date().toISOString()
      };
      await saveNoteToDB(note);
      currentNote = note;
      await loadNotesList();
    } catch (err) {
      console.error('Failed saving imported note', err);
    }

    // close the modal
    const modal = document.getElementById('import-iframe-modal');
    if (modal) {
      modal.classList.add('hidden');
      modal.setAttribute('aria-hidden', 'true');
      iframe.src = window.location.origin + '/import.html';
    }
  });

  </script>
</body>
</html>
